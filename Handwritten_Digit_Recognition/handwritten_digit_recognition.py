# -*- coding: utf-8 -*-
"""Handwritten_digit_recognition.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13rBWYu8KFxeq7uNc-vAi1aR2_Jm-ltOc

# 1. Data Preparation
"""

from sklearn.datasets import fetch_openml
mnist = fetch_openml('mnist_784', version=1)

print(mnist.keys())
dict_keys = mnist.keys()

mnist['data']

mnist['target']



import numpy as np
import pandas as pd


print((np.array(mnist.data.iloc[0]).reshape(28, 28) > 0).astype(int))
# this number is indeed  mambo 'number five'

from matplotlib import pyplot as plt
pixels = np.array(mnist.data.loc[0]).reshape(28, 28)
plt.imshow(pixels, cmap='gray')
plt.show()

"""# 2. Train and test set

## Manual devide without shuffle to see why the shuffle is necessary
"""

X = mnist['data'] # dataFrame already
y = mnist['target'] # by default Series (1D dataFrame)
y = y.sort_values()

type(X)

X.describe()

X = X.reindex(list(y.index))
X # X sorted by index order in y (y was sorted by it label from numbers representing '0' to '9')

X_train, X_test = X[:56000], X[56000:]
y_train, y_test = y[:56000], y[56000:]
print(X_train.shape, y_train.shape)
print(X_test.shape, y_test.shape)

print(y_train.unique())
print(y_test.unique())

"""**we can see that now there is no data that depicts number 8 or 9 in the training sample, so our model doesnt have data to learn how to recognise these two numbers.**

## Devide with shuffle by train_test_split method
"""

from sklearn.model_selection import train_test_split

X_train, X_test, y_train, y_test = train_test_split(X, y,test_size=0.2, shuffle = True) # no random_state=42
# we save the shuffled X and y in the same variable (so if you want to use sorted ones again, point to the code above)

print(X_train.shape, y_train.shape)
print(X_test.shape, y_test.shape)

print(y_train.unique())
print(y_test.unique())

"""**now we have data representing all numbers from 0 to 9 in train set sample, so model can learn how to recognise all types of numbers**

# 3. Model learning, one class
"""

y_train_zero = (y_train.astype(int) == 0) # we create an array which points at numbers classified as 'zeros'.
y_test_zero = (y_test.astype(int) == 0) # we create an array which points at numbers classified as 'zeros'.

"""## Teaching a Stochastic Gradient Descent classifier to detect the digit 0."""

from sklearn.linear_model import SGDClassifier

sgd_clf = SGDClassifier() # 42?
sgd_clf.fit(X_train, y_train_zero)

import pickle

y_train_pred = sgd_clf.predict(X_train)
y_test_pred = sgd_clf.predict(X_test)
acc_train = sum(y_train_pred == y_train_zero)/len(y_train_zero)
acc_test = sum(y_test_pred == y_test_zero)/len(y_test_zero)

accuracy_zero = np.array([acc_train, acc_test])  # saving to ndarray (2, size) numpy. (pd.Dataframe(accuracy_zero) made it (2,1) size, but we wanted (2,).
with open("sgd_acc.pkl", "wb") as f:
    pickle.dump(accuracy_zero, f)

from sklearn.metrics import confusion_matrix

print(confusion_matrix(y_train_zero, y_train_pred))

print(confusion_matrix(y_test_zero, y_test_pred))

from sklearn.model_selection import cross_val_score
import pickle

accuracy_zero_kfold = cross_val_score(sgd_clf, X_train, y_train_zero,cv=3, scoring="accuracy",n_jobs=-1)
accuracy_zero_kfold = np.array(accuracy_zero_kfold)

# numpy object doesnt have the .to_pickle() method, so i decided to use the method below
with open("sgd_cva.pkl", "wb") as f:
    pickle.dump(accuracy_zero_kfold, f)

"""**W ecalculated 3-point cross validation for our training model.**"""

from sklearn.model_selection import cross_val_predict
from sklearn.metrics import confusion_matrix
y_train_pred = cross_val_predict(sgd_clf, X_train ,y_train_zero, cv=3,n_jobs=-1)
print(confusion_matrix(y_train_zero, y_train_pred))

"""**And confusion matrix as well**"""

from sklearn.metrics import precision_score, recall_score, f1_score

print(precision_score(y_train_zero, y_train_pred)) #precision
print(recall_score(y_train_zero, y_train_pred)) #recall
print(f1_score(y_train_zero, y_train_pred)) #f1

"""## Teaching a Stochastic Gradient Descent classifier to detect all types of digits from 0 to 9."""

sgd_m_clf = SGDClassifier(n_jobs=-1) # no random_state=42
sgd_m_clf.fit(X_train, y_train.astype(int))

print(sgd_m_clf.predict([mnist["data"].iloc[0], mnist["data"].iloc[1]]))

print(cross_val_score(sgd_m_clf, X_train, y_train,cv=3, scoring="accuracy", n_jobs=-1))
y_train_pred = cross_val_predict(sgd_m_clf, X_train, y_train, cv=3, n_jobs=-1)
conf_mx = confusion_matrix(y_train, y_train_pred)
print(conf_mx)
conf_mx = np.array(conf_mx)
with open("sgd_cmx.pkl", "wb") as f:
    pickle.dump(conf_mx, f)

